From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qmuntal <qmuntaldiaz@microsoft.com>
Date: Thu, 30 Jun 2022 10:03:03 +0200
Subject: [PATCH] Add crypto backend foundation

---
 src/cmd/api/boring_test.go                    |   2 +-
 src/cmd/go/go_boring_test.go                  |   2 +-
 src/crypto/aes/aes.go                         |   2 +-
 src/crypto/boring/boring.go                   |   4 +-
 src/crypto/cipher/ctr_aes_test.go             |   2 +-
 src/crypto/cipher/gcm_test.go                 |   2 +-
 src/crypto/des/cipher.go                      |   7 +
 src/crypto/dsa/boring.go                      | 113 +++++++++
 src/crypto/dsa/dsa.go                         |  88 +++++++
 src/crypto/dsa/notboring.go                   |  16 ++
 src/crypto/ecdh/ecdh.go                       |   2 +-
 src/crypto/ecdh/ecdh_test.go                  |   4 +
 src/crypto/ecdh/nist.go                       |   2 +-
 src/crypto/ecdsa/boring.go                    |   6 +-
 src/crypto/ecdsa/ecdsa.go                     |   4 +-
 src/crypto/ecdsa/notboring.go                 |   4 +-
 src/crypto/ed25519/boring.go                  |  71 ++++++
 src/crypto/ed25519/ed25519.go                 |  73 ++++++
 src/crypto/ed25519/notboring.go               |  16 ++
 src/crypto/hkdf/hkdf_test.go                  |   2 +-
 src/crypto/hmac/hmac.go                       |   2 +-
 src/crypto/hmac/hmac_test.go                  |   2 +-
 src/crypto/internal/backend/backend_test.go   |  30 +++
 src/crypto/internal/backend/bbig/big.go       |  17 ++
 src/crypto/internal/backend/common.go         |  72 ++++++
 .../internal/backend/fips140/fips140.go       |  55 +++++
 .../internal/backend/fips140/isrequirefips.go |   9 +
 .../internal/backend/fips140/norequirefips.go |   9 +
 .../backend/fips140/nosystemcrypto.go         |  11 +
 src/crypto/internal/backend/nobackend.go      | 229 ++++++++++++++++++
 src/crypto/internal/backend/stub.s            |  10 +
 src/crypto/internal/cryptotest/allocations.go |   2 +-
 .../internal/cryptotest/implementations.go    |   2 +-
 src/crypto/md5/md5.go                         |   7 +
 src/crypto/md5/md5_test.go                    |  14 ++
 src/crypto/pbkdf2/pbkdf2.go                   |   4 +
 src/crypto/pbkdf2/pbkdf2_test.go              |   2 +-
 src/crypto/purego_test.go                     |   2 +-
 src/crypto/rand/rand.go                       |   2 +-
 src/crypto/rc4/rc4.go                         |  18 ++
 src/crypto/rsa/boring.go                      |   6 +-
 src/crypto/rsa/boring_test.go                 |   2 +-
 src/crypto/rsa/fips.go                        |  10 +-
 src/crypto/rsa/notboring.go                   |   4 +-
 src/crypto/rsa/pkcs1v15.go                    |   6 +-
 src/crypto/rsa/pkcs1v15_test.go               |   5 +
 src/crypto/rsa/pss_test.go                    |   5 +
 src/crypto/rsa/rsa.go                         |   4 +-
 src/crypto/rsa/rsa_test.go                    |  12 +-
 src/crypto/sha1/sha1.go                       |   2 +-
 src/crypto/sha1/sha1_test.go                  |  12 +-
 src/crypto/sha256/sha256.go                   |   6 +-
 src/crypto/sha256/sha256_test.go              |  19 ++
 src/crypto/sha512/sha512.go                   |   2 +-
 src/crypto/sha512/sha512_test.go              |  19 ++
 src/crypto/tls/cipher_suites.go               |   2 +-
 src/crypto/tls/fipsonly/fipsonly.go           |   2 +-
 src/crypto/tls/fipsonly/fipsonly_test.go      |   2 +-
 src/crypto/tls/handshake_client.go            |  10 +-
 src/crypto/tls/handshake_server.go            |  10 +-
 src/crypto/tls/handshake_server_tls13.go      |  10 +
 src/crypto/tls/internal/fips140tls/fipstls.go |   3 +-
 src/crypto/tls/prf.go                         |  41 ++++
 src/go/build/deps_test.go                     |   8 +-
 src/hash/boring_test.go                       |   9 +
 src/hash/example_test.go                      |   2 +
 src/hash/marshal_test.go                      |   5 +
 src/hash/notboring_test.go                    |   9 +
 src/net/smtp/smtp_test.go                     |  72 ++++--
 src/runtime/runtime_boring.go                 |   5 +
 70 files changed, 1145 insertions(+), 80 deletions(-)
 create mode 100644 src/crypto/dsa/boring.go
 create mode 100644 src/crypto/dsa/notboring.go
 create mode 100644 src/crypto/ed25519/boring.go
 create mode 100644 src/crypto/ed25519/notboring.go
 create mode 100644 src/crypto/internal/backend/backend_test.go
 create mode 100644 src/crypto/internal/backend/bbig/big.go
 create mode 100644 src/crypto/internal/backend/common.go
 create mode 100644 src/crypto/internal/backend/fips140/fips140.go
 create mode 100644 src/crypto/internal/backend/fips140/isrequirefips.go
 create mode 100644 src/crypto/internal/backend/fips140/norequirefips.go
 create mode 100644 src/crypto/internal/backend/fips140/nosystemcrypto.go
 create mode 100644 src/crypto/internal/backend/nobackend.go
 create mode 100644 src/crypto/internal/backend/stub.s
 create mode 100644 src/hash/boring_test.go
 create mode 100644 src/hash/notboring_test.go

diff --git a/src/cmd/api/boring_test.go b/src/cmd/api/boring_test.go
index f0e3575637c62a..9eab3b4e66e60b 100644
--- a/src/cmd/api/boring_test.go
+++ b/src/cmd/api/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package main
 
diff --git a/src/cmd/go/go_boring_test.go b/src/cmd/go/go_boring_test.go
index ed0fbf3d53d75b..06478963f4be44 100644
--- a/src/cmd/go/go_boring_test.go
+++ b/src/cmd/go/go_boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package main_test
 
diff --git a/src/crypto/aes/aes.go b/src/crypto/aes/aes.go
index 5bc2d13d673e0a..b803c77be62a66 100644
--- a/src/crypto/aes/aes.go
+++ b/src/crypto/aes/aes.go
@@ -15,7 +15,7 @@ package aes
 
 import (
 	"crypto/cipher"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/aes"
 	"strconv"
 )
diff --git a/src/crypto/boring/boring.go b/src/crypto/boring/boring.go
index 097c37e343fdb8..a5d603896d3890 100644
--- a/src/crypto/boring/boring.go
+++ b/src/crypto/boring/boring.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 // Package boring exposes functions that are only available when building with
 // Go+BoringCrypto. This package is available on all targets as long as the
@@ -13,7 +13,7 @@
 // is satisfied, so that applications can tag files that use this package.
 package boring
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 // Enabled reports whether BoringCrypto handles supported crypto operations.
 func Enabled() bool {
diff --git a/src/crypto/cipher/ctr_aes_test.go b/src/crypto/cipher/ctr_aes_test.go
index 33942467784ad3..0282ffa9fa23c8 100644
--- a/src/crypto/cipher/ctr_aes_test.go
+++ b/src/crypto/cipher/ctr_aes_test.go
@@ -14,7 +14,7 @@ import (
 	"bytes"
 	"crypto/aes"
 	"crypto/cipher"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	fipsaes "crypto/internal/fips140/aes"
 	"encoding/hex"
diff --git a/src/crypto/cipher/gcm_test.go b/src/crypto/cipher/gcm_test.go
index ea2b4e29e2b67f..f884b0d0fbefe7 100644
--- a/src/crypto/cipher/gcm_test.go
+++ b/src/crypto/cipher/gcm_test.go
@@ -8,7 +8,7 @@ import (
 	"bytes"
 	"crypto/aes"
 	"crypto/cipher"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/internal/fips140"
 	fipsaes "crypto/internal/fips140/aes"
diff --git a/src/crypto/des/cipher.go b/src/crypto/des/cipher.go
index 21303b384cf757..0d3c4f810cfd8f 100644
--- a/src/crypto/des/cipher.go
+++ b/src/crypto/des/cipher.go
@@ -6,6 +6,7 @@ package des
 
 import (
 	"crypto/cipher"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/alias"
 	"crypto/internal/fips140only"
 	"errors"
@@ -36,6 +37,9 @@ func NewCipher(key []byte) (cipher.Block, error) {
 	if len(key) != 8 {
 		return nil, KeySizeError(len(key))
 	}
+	if boring.Enabled && boring.SupportsDESCipher() {
+		return boring.NewDESCipher(key)
+	}
 
 	c := new(desCipher)
 	c.generateSubkeys(key)
@@ -84,6 +88,9 @@ func NewTripleDESCipher(key []byte) (cipher.Block, error) {
 	if len(key) != 24 {
 		return nil, KeySizeError(len(key))
 	}
+	if boring.Enabled && boring.SupportsTripleDESCipher() {
+		return boring.NewTripleDESCipher(key)
+	}
 
 	c := new(tripleDESCipher)
 	c.cipher1.generateSubkeys(key[:8])
diff --git a/src/crypto/dsa/boring.go b/src/crypto/dsa/boring.go
new file mode 100644
index 00000000000000..7ea0c8c423e9ee
--- /dev/null
+++ b/src/crypto/dsa/boring.go
@@ -0,0 +1,113 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.systemcrypto
+
+package dsa
+
+import (
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
+	"crypto/internal/boring/bcache"
+	"math/big"
+)
+
+// Cached conversions from Go PublicKey/PrivateKey to BoringCrypto.
+//
+// The first operation on a PublicKey or PrivateKey makes a parallel
+// BoringCrypto key and saves it in pubCache or privCache.
+//
+// We could just assume that once used in a sign/verify/encrypt/decrypt operation,
+// a particular key is never again modified, but that has not been a
+// stated assumption before. Just in case there is any existing code that
+// does modify the key between operations, we save the original values
+// alongside the cached BoringCrypto key and check that the real key
+// still matches before using the cached key. The theory is that the real
+// operations are significantly more expensive than the comparison.
+
+type boringPub struct {
+	key  *boring.PublicKeyDSA
+	orig PublicKey
+}
+
+var pubCache bcache.Cache[PublicKey, boringPub]
+var privCache bcache.Cache[PrivateKey, boringPriv]
+
+func init() {
+	pubCache.Register()
+	privCache.Register()
+}
+
+func boringPublicKey(pub *PublicKey) (*boring.PublicKeyDSA, error) {
+	b := pubCache.Get(pub)
+	if b != nil && publicKeyEqual(&b.orig, pub) {
+		return b.key, nil
+	}
+
+	b = new(boringPub)
+	b.orig = copyPublicKey(pub)
+	key, err := boring.NewPublicKeyDSA(bbig.Enc(b.orig.P), bbig.Enc(b.orig.Q), bbig.Enc(b.orig.G), bbig.Enc(b.orig.Y))
+	if err != nil {
+		return nil, err
+	}
+	b.key = key
+	pubCache.Put(pub, b)
+	return key, nil
+}
+
+type boringPriv struct {
+	key  *boring.PrivateKeyDSA
+	orig PrivateKey
+}
+
+func boringPrivateKey(priv *PrivateKey) (*boring.PrivateKeyDSA, error) {
+	b := privCache.Get(priv)
+	if b != nil && privateKeyEqual(&b.orig, priv) {
+		return b.key, nil
+	}
+
+	b = new(boringPriv)
+	b.orig = copyPrivateKey(priv)
+
+	P := b.orig.P
+	Q := b.orig.Q
+	G := b.orig.G
+	X := b.orig.X
+	Y := b.orig.Y
+
+	key, err := boring.NewPrivateKeyDSA(bbig.Enc(P), bbig.Enc(Q), bbig.Enc(G), bbig.Enc(X), bbig.Enc(Y))
+	if err != nil {
+		return nil, err
+	}
+	b.key = key
+	privCache.Put(priv, b)
+	return key, nil
+}
+
+func publicKeyEqual(k1, k2 *PublicKey) bool {
+	return k1.Y != nil && k1.Y.Cmp(k2.Y) == 0 && k1.P.Cmp(k2.P) == 0 && k1.Q.Cmp(k2.Q) == 0 && k1.G.Cmp(k2.G) == 0
+}
+
+func copyPublicKey(k *PublicKey) PublicKey {
+	return PublicKey{
+		Parameters: Parameters{
+			P: new(big.Int).Set(k.P),
+			Q: new(big.Int).Set(k.Q),
+			G: new(big.Int).Set(k.G),
+		},
+		Y: new(big.Int).Set(k.Y),
+	}
+}
+
+func privateKeyEqual(k1, k2 *PrivateKey) bool {
+	return publicKeyEqual(&k1.PublicKey, &k2.PublicKey) &&
+		k1.X.Cmp(k2.X) == 0
+}
+
+func copyPrivateKey(k *PrivateKey) PrivateKey {
+	return PrivateKey{
+		PublicKey: copyPublicKey(&k.PublicKey),
+		X:         new(big.Int).Set(k.X),
+	}
+}
diff --git a/src/crypto/dsa/dsa.go b/src/crypto/dsa/dsa.go
index 000becc82dfb79..6430bb3ea5e437 100644
--- a/src/crypto/dsa/dsa.go
+++ b/src/crypto/dsa/dsa.go
@@ -18,8 +18,13 @@ import (
 	"io"
 	"math/big"
 
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/fips140only"
 	"crypto/internal/randutil"
+
+	"golang.org/x/crypto/cryptobyte"
+	"golang.org/x/crypto/cryptobyte/asn1"
 )
 
 // Parameters represents the domain parameters for a key. These parameters can
@@ -91,6 +96,17 @@ func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes
 		return errors.New("crypto/dsa: invalid ParameterSizes")
 	}
 
+	if boring.Enabled && boring.SupportsDSA(L, N) {
+		p, q, g, err := boring.GenerateParametersDSA(L, N)
+		if err != nil {
+			return err
+		}
+		params.P = bbig.Dec(p)
+		params.Q = bbig.Dec(q)
+		params.G = bbig.Dec(g)
+		return nil
+	}
+
 	qBytes := make([]byte, N/8)
 	pBytes := make([]byte, L/8)
 
@@ -170,6 +186,17 @@ func GenerateKey(priv *PrivateKey, rand io.Reader) error {
 		return errors.New("crypto/dsa: parameters not set up before generating key")
 	}
 
+	if boring.Enabled && boring.SupportsDSA(priv.P.BitLen(), priv.Q.BitLen()) {
+		x, y, err := boring.GenerateKeyDSA(bbig.Enc(priv.P), bbig.Enc(priv.Q), bbig.Enc(priv.G))
+		if err != nil {
+			return err
+		}
+		priv.X = bbig.Dec(x)
+		priv.Y = bbig.Dec(y)
+
+		return nil
+	}
+
 	x := new(big.Int)
 	xBytes := make([]byte, priv.Q.BitLen()/8)
 
@@ -225,6 +252,18 @@ func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err err
 		err = ErrInvalidPublicKey
 		return
 	}
+
+	if boring.Enabled && boring.SupportsDSA(priv.P.BitLen(), priv.Q.BitLen()) {
+		b, err := boringPrivateKey(priv)
+		if err != nil {
+			return nil, nil, err
+		}
+
+		r, s, err := boring.SignDSA(b, hash, parseSignature)
+
+		return bbig.Dec(r), bbig.Dec(s), err
+	}
+
 	n >>= 3
 
 	var attempts int
@@ -288,6 +327,14 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
 		panic("crypto/dsa: use of DSA is not allowed in FIPS 140-only mode")
 	}
 
+	if boring.Enabled && boring.SupportsDSA(pub.P.BitLen(), pub.Q.BitLen()) {
+		bkey, err := boringPublicKey(pub)
+		if err != nil {
+			return false
+		}
+
+		return boring.VerifyDSA(bkey, hash, bbig.Enc(r), bbig.Enc(s), encodeSignature)
+	}
 	// FIPS 186-3, section 4.7
 
 	if pub.P.Sign() == 0 {
@@ -324,3 +371,44 @@ func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {
 
 	return v.Cmp(r) == 0
 }
+
+func parseSignature(sig []byte) (boring.BigInt, boring.BigInt, error) {
+	var r, s []byte
+	var inner cryptobyte.String
+	input := cryptobyte.String(sig)
+	if !input.ReadASN1(&inner, asn1.SEQUENCE) ||
+		!input.Empty() ||
+		!inner.ReadASN1Integer(&r) ||
+		!inner.ReadASN1Integer(&s) ||
+		!inner.Empty() {
+		return nil, nil, errors.New("invalid ASN.1")
+	}
+	return bbig.Enc(new(big.Int).SetBytes(r)), bbig.Enc(new(big.Int).SetBytes(s)), nil
+}
+
+func encodeSignature(r, s boring.BigInt) ([]byte, error) {
+	var b cryptobyte.Builder
+	b.AddASN1(asn1.SEQUENCE, func(b *cryptobyte.Builder) {
+		addASN1IntBytes(b, bbig.Dec(r).Bytes())
+		addASN1IntBytes(b, bbig.Dec(s).Bytes())
+	})
+	return b.Bytes()
+}
+
+// addASN1IntBytes encodes in ASN.1 a positive integer represented as
+// a big-endian byte slice with zero or more leading zeroes.
+func addASN1IntBytes(b *cryptobyte.Builder, bytes []byte) {
+	for len(bytes) > 0 && bytes[0] == 0 {
+		bytes = bytes[1:]
+	}
+	if len(bytes) == 0 {
+		b.SetError(errors.New("invalid integer"))
+		return
+	}
+	b.AddASN1(asn1.INTEGER, func(c *cryptobyte.Builder) {
+		if bytes[0]&0x80 != 0 {
+			c.AddUint8(0)
+		}
+		c.AddBytes(bytes)
+	})
+}
diff --git a/src/crypto/dsa/notboring.go b/src/crypto/dsa/notboring.go
new file mode 100644
index 00000000000000..cd02ff5a00c3dc
--- /dev/null
+++ b/src/crypto/dsa/notboring.go
@@ -0,0 +1,16 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package dsa
+
+import boring "crypto/internal/backend"
+
+func boringPublicKey(*PublicKey) (*boring.PublicKeyDSA, error) {
+	panic("boringcrypto: not available")
+}
+func boringPrivateKey(*PrivateKey) (*boring.PrivateKeyDSA, error) {
+	panic("boringcrypto: not available")
+}
diff --git a/src/crypto/ecdh/ecdh.go b/src/crypto/ecdh/ecdh.go
index 231f1ea04c1010..cfa113e2345816 100644
--- a/src/crypto/ecdh/ecdh.go
+++ b/src/crypto/ecdh/ecdh.go
@@ -8,7 +8,7 @@ package ecdh
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/ecdh"
 	"crypto/subtle"
 	"errors"
diff --git a/src/crypto/ecdh/ecdh_test.go b/src/crypto/ecdh/ecdh_test.go
index 75d2480775669f..6a4d26fbafe090 100644
--- a/src/crypto/ecdh/ecdh_test.go
+++ b/src/crypto/ecdh/ecdh_test.go
@@ -9,6 +9,7 @@ import (
 	"crypto"
 	"crypto/cipher"
 	"crypto/ecdh"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	"crypto/sha256"
 	"encoding/hex"
@@ -280,6 +281,9 @@ var invalidPrivateKeys = map[ecdh.Curve][]string{
 }
 
 func TestNewPrivateKey(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("skipping test with different results when using different backends")
+	}
 	testAllCurves(t, func(t *testing.T, curve ecdh.Curve) {
 		for _, input := range invalidPrivateKeys[curve] {
 			k, err := curve.NewPrivateKey(hexDecode(t, input))
diff --git a/src/crypto/ecdh/nist.go b/src/crypto/ecdh/nist.go
index acef8298943c2b..ca6171cf775117 100644
--- a/src/crypto/ecdh/nist.go
+++ b/src/crypto/ecdh/nist.go
@@ -6,7 +6,7 @@ package ecdh
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/ecdh"
 	"crypto/internal/fips140only"
 	"errors"
diff --git a/src/crypto/ecdsa/boring.go b/src/crypto/ecdsa/boring.go
index 275c60b4de49eb..ff8bddf28c4545 100644
--- a/src/crypto/ecdsa/boring.go
+++ b/src/crypto/ecdsa/boring.go
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package ecdsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/boring/bcache"
 	"math/big"
 )
diff --git a/src/crypto/ecdsa/ecdsa.go b/src/crypto/ecdsa/ecdsa.go
index 77727aaf96befb..dedaa0fe4100b1 100644
--- a/src/crypto/ecdsa/ecdsa.go
+++ b/src/crypto/ecdsa/ecdsa.go
@@ -18,8 +18,8 @@ import (
 	"crypto"
 	"crypto/ecdh"
 	"crypto/elliptic"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/fips140/ecdsa"
 	"crypto/internal/fips140only"
 	"crypto/internal/randutil"
diff --git a/src/crypto/ecdsa/notboring.go b/src/crypto/ecdsa/notboring.go
index 039bd82ed21f9f..69a97d9bf250be 100644
--- a/src/crypto/ecdsa/notboring.go
+++ b/src/crypto/ecdsa/notboring.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build !goexperiment.systemcrypto
 
 package ecdsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyECDSA, error) {
 	panic("boringcrypto: not available")
diff --git a/src/crypto/ed25519/boring.go b/src/crypto/ed25519/boring.go
new file mode 100644
index 00000000000000..3a7d7b76c8d8d7
--- /dev/null
+++ b/src/crypto/ed25519/boring.go
@@ -0,0 +1,71 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.systemcrypto
+
+package ed25519
+
+import (
+	boring "crypto/internal/backend"
+	"crypto/internal/boring/bcache"
+	"unsafe"
+)
+
+var pubCache bcache.Cache[byte, boringPub]
+var privCache bcache.Cache[byte, boringPriv]
+
+func init() {
+	if boring.Enabled && boring.SupportsEd25519() {
+		pubCache.Register()
+		privCache.Register()
+	}
+}
+
+type boringPub struct {
+	key  *boring.PublicKeyEd25519
+	orig [PublicKeySize]byte
+}
+
+func boringPublicKey(pub PublicKey) (*boring.PublicKeyEd25519, error) {
+	// Use the pointer to the underlying pub array as key.
+	p := unsafe.SliceData(pub)
+	b := pubCache.Get(p)
+	if b != nil && PublicKey(b.orig[:]).Equal(pub) {
+		return b.key, nil
+	}
+
+	b = new(boringPub)
+	copy(b.orig[:], pub)
+	key, err := boring.NewPublicKeyEd25119(b.orig[:])
+	if err != nil {
+		return nil, err
+	}
+	b.key = key
+	pubCache.Put(p, b)
+	return key, nil
+}
+
+type boringPriv struct {
+	key  *boring.PrivateKeyEd25519
+	orig [PrivateKeySize]byte
+}
+
+func boringPrivateKey(priv PrivateKey) (*boring.PrivateKeyEd25519, error) {
+	// Use the pointer to the underlying priv array as key.
+	p := unsafe.SliceData(priv)
+	b := privCache.Get(p)
+	if b != nil && PrivateKey(b.orig[:]).Equal(priv) {
+		return b.key, nil
+	}
+
+	b = new(boringPriv)
+	copy(b.orig[:], priv)
+	key, err := boring.NewPrivateKeyEd25119(b.orig[:])
+	if err != nil {
+		return nil, err
+	}
+	b.key = key
+	privCache.Put(p, b)
+	return key, nil
+}
diff --git a/src/crypto/ed25519/ed25519.go b/src/crypto/ed25519/ed25519.go
index c1f8ff784e4a5c..308d814ff6302b 100644
--- a/src/crypto/ed25519/ed25519.go
+++ b/src/crypto/ed25519/ed25519.go
@@ -17,6 +17,7 @@ package ed25519
 
 import (
 	"crypto"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/ed25519"
 	"crypto/internal/fips140only"
 	cryptorand "crypto/rand"
@@ -24,6 +25,7 @@ import (
 	"errors"
 	"io"
 	"strconv"
+	"sync"
 )
 
 const (
@@ -138,6 +140,22 @@ func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error) {
 	if rand == nil {
 		rand = cryptorand.Reader
 	}
+	if boring.Enabled && boring.SupportsEd25519() {
+		if rand == boring.RandReader {
+			priv, err := boring.GenerateKeyEd25519()
+			if err != nil {
+				return nil, nil, err
+			}
+			privData, err := priv.Bytes()
+			if err != nil {
+				return nil, nil, err
+			}
+			privKey := PrivateKey(privData)
+			pubKey := privKey.Public().(PublicKey)
+			return pubKey, privKey, err
+		}
+		boring.UnreachableExceptTests()
+	}
 
 	seed := make([]byte, SeedSize)
 	if _, err := io.ReadFull(rand, seed); err != nil {
@@ -154,6 +172,17 @@ func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error) {
 // with RFC 8032. RFC 8032's private keys correspond to seeds in this
 // package.
 func NewKeyFromSeed(seed []byte) PrivateKey {
+	if boring.Enabled && boring.SupportsEd25519() {
+		key, err := boring.NewPrivateKeyEd25519FromSeed(seed)
+		if err != nil {
+			panic(err)
+		}
+		d, err := key.Bytes()
+		if err != nil {
+			panic(err)
+		}
+		return PrivateKey(d)
+	}
 	// Outline the function body so that the returned key can be stack-allocated.
 	privateKey := make([]byte, PrivateKeySize)
 	newKeyFromSeed(privateKey, seed)
@@ -172,6 +201,17 @@ func newKeyFromSeed(privateKey, seed []byte) {
 // Sign signs the message with privateKey and returns a signature. It will
 // panic if len(privateKey) is not [PrivateKeySize].
 func Sign(privateKey PrivateKey, message []byte) []byte {
+	if boring.Enabled && boring.SupportsEd25519() {
+		priv, err := boringPrivateKey(privateKey)
+		if err != nil {
+			panic(err)
+		}
+		signature, err := boring.SignEd25519(priv, message)
+		if err != nil {
+			panic(err)
+		}
+		return signature
+	}
 	// Outline the function body so that the returned signature can be
 	// stack-allocated.
 	signature := make([]byte, SignatureSize)
@@ -200,6 +240,32 @@ func Verify(publicKey PublicKey, message, sig []byte) bool {
 	return VerifyWithOptions(publicKey, message, sig, &Options{Hash: crypto.Hash(0)}) == nil
 }
 
+// testMalleability returns true if the crypto backend correctly rejects
+// malleable signatures. The only known backend that fails to do so is
+// OpenSSL version 1.1.1a or lower.
+// See https://github.com/openssl/openssl/issues/7693.
+var testMalleability = sync.OnceValue(func() bool {
+	msg := []byte{0x54, 0x65, 0x73, 0x74}
+	sig := []byte{
+		0x7c, 0x38, 0xe0, 0x26, 0xf2, 0x9e, 0x14, 0xaa, 0xbd, 0x05, 0x9a,
+		0x0f, 0x2d, 0xb8, 0xb0, 0xcd, 0x78, 0x30, 0x40, 0x60, 0x9a, 0x8b,
+		0xe6, 0x84, 0xdb, 0x12, 0xf8, 0x2a, 0x27, 0x77, 0x4a, 0xb0, 0x67,
+		0x65, 0x4b, 0xce, 0x38, 0x32, 0xc2, 0xd7, 0x6f, 0x8f, 0x6f, 0x5d,
+		0xaf, 0xc0, 0x8d, 0x93, 0x39, 0xd4, 0xee, 0xf6, 0x76, 0x57, 0x33,
+		0x36, 0xa5, 0xc5, 0x1e, 0xb6, 0xf9, 0x46, 0xb3, 0x1d,
+	}
+	pkey := []byte{
+		0x7d, 0x4d, 0x0e, 0x7f, 0x61, 0x53, 0xa6, 0x9b, 0x62, 0x42, 0xb5,
+		0x22, 0xab, 0xbe, 0xe6, 0x85, 0xfd, 0xa4, 0x42, 0x0f, 0x88, 0x34,
+		0xb1, 0x08, 0xc3, 0xbd, 0xae, 0x36, 0x9e, 0xf5, 0x49, 0xfa,
+	}
+	pub, err := boring.NewPublicKeyEd25119(pkey)
+	if err != nil {
+		return false
+	}
+	return boring.VerifyEd25519(pub, msg, sig) != nil
+})
+
 // VerifyWithOptions reports whether sig is a valid signature of message by
 // publicKey. A valid signature is indicated by returning a nil error. It will
 // panic if len(publicKey) is not [PublicKeySize].
@@ -228,6 +294,13 @@ func VerifyWithOptions(publicKey PublicKey, message, sig []byte, opts *Options)
 		}
 		return ed25519.VerifyCtx(k, message, sig, opts.Context)
 	case opts.Hash == crypto.Hash(0): // Ed25519
+		if boring.Enabled && boring.SupportsEd25519() && testMalleability() {
+			pub, err := boringPublicKey(publicKey)
+			if err != nil {
+				return err
+			}
+			return boring.VerifyEd25519(pub, message, sig)
+		}
 		return ed25519.Verify(k, message, sig)
 	default:
 		return errors.New("ed25519: expected opts.Hash zero (unhashed message, for standard Ed25519) or SHA-512 (for Ed25519ph)")
diff --git a/src/crypto/ed25519/notboring.go b/src/crypto/ed25519/notboring.go
new file mode 100644
index 00000000000000..b0cdd44d81c753
--- /dev/null
+++ b/src/crypto/ed25519/notboring.go
@@ -0,0 +1,16 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package ed25519
+
+import boring "crypto/internal/backend"
+
+func boringPublicKey(PublicKey) (*boring.PublicKeyEd25519, error) {
+	panic("boringcrypto: not available")
+}
+func boringPrivateKey(PrivateKey) (*boring.PrivateKeyEd25519, error) {
+	panic("boringcrypto: not available")
+}
diff --git a/src/crypto/hkdf/hkdf_test.go b/src/crypto/hkdf/hkdf_test.go
index 201b440289bb2d..4ed4960ff35b66 100644
--- a/src/crypto/hkdf/hkdf_test.go
+++ b/src/crypto/hkdf/hkdf_test.go
@@ -6,7 +6,7 @@ package hkdf
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	"crypto/md5"
 	"crypto/sha1"
diff --git a/src/crypto/hmac/hmac.go b/src/crypto/hmac/hmac.go
index 72f5a4abea9d35..c88c6cbd128451 100644
--- a/src/crypto/hmac/hmac.go
+++ b/src/crypto/hmac/hmac.go
@@ -22,7 +22,7 @@ timing side-channels:
 package hmac
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/hmac"
 	"crypto/internal/fips140only"
 	"crypto/subtle"
diff --git a/src/crypto/hmac/hmac_test.go b/src/crypto/hmac/hmac_test.go
index 7accad763244a1..dd3211f2c37af3 100644
--- a/src/crypto/hmac/hmac_test.go
+++ b/src/crypto/hmac/hmac_test.go
@@ -5,7 +5,7 @@
 package hmac
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/md5"
 	"crypto/sha1"
diff --git a/src/crypto/internal/backend/backend_test.go b/src/crypto/internal/backend/backend_test.go
new file mode 100644
index 00000000000000..c2c06d3bff8c74
--- /dev/null
+++ b/src/crypto/internal/backend/backend_test.go
@@ -0,0 +1,30 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package backend
+
+import (
+	"testing"
+)
+
+// Test that Unreachable panics.
+func TestUnreachable(t *testing.T) {
+	defer func() {
+		if Enabled {
+			if err := recover(); err == nil {
+				t.Fatal("expected Unreachable to panic")
+			}
+		} else {
+			if err := recover(); err != nil {
+				t.Fatalf("expected Unreachable to be a no-op")
+			}
+		}
+	}()
+	Unreachable()
+}
+
+// Test that UnreachableExceptTests does not panic (this is a test).
+func TestUnreachableExceptTests(t *testing.T) {
+	UnreachableExceptTests()
+}
diff --git a/src/crypto/internal/backend/bbig/big.go b/src/crypto/internal/backend/bbig/big.go
new file mode 100644
index 00000000000000..20251a290dc2e0
--- /dev/null
+++ b/src/crypto/internal/backend/bbig/big.go
@@ -0,0 +1,17 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package bbig
+
+import "math/big"
+
+func Enc(b *big.Int) []uint {
+	return nil
+}
+
+func Dec(b []uint) *big.Int {
+	return nil
+}
diff --git a/src/crypto/internal/backend/common.go b/src/crypto/internal/backend/common.go
new file mode 100644
index 00000000000000..858e76e3c51c06
--- /dev/null
+++ b/src/crypto/internal/backend/common.go
@@ -0,0 +1,72 @@
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package backend
+
+import (
+	"crypto/internal/backend/fips140"
+	"crypto/internal/boring/sig"
+	"internal/goexperiment"
+	"runtime"
+)
+
+func init() {
+	if fips140.Enabled() {
+		if !Enabled {
+			if runtime.GOOS != "linux" && runtime.GOOS != "windows" {
+				panic("FIPS mode requested (" + fips140.Message + ") but no crypto backend is supported on " + runtime.GOOS)
+			}
+			panic("FIPS mode requested (" + fips140.Message + ") but no supported crypto backend is enabled")
+		}
+	}
+}
+
+// Unreachable marks code that should be unreachable
+// when backend is in use.
+func Unreachable() {
+	if Enabled {
+		panic("cryptobackend: invalid code execution")
+	} else {
+		// Code that's unreachable is exactly the code
+		// we want to detect for reporting standard Go crypto.
+		sig.StandardCrypto()
+	}
+}
+
+// Provided by runtime.crypto_backend_runtime_arg0 to avoid os import.
+func runtime_arg0() string
+
+func hasSuffix(s, t string) bool {
+	return len(s) > len(t) && s[len(s)-len(t):] == t
+}
+
+// UnreachableExceptTests marks code that should be unreachable
+// when backend is in use. It panics.
+func UnreachableExceptTests() {
+	if Enabled {
+		name := runtime_arg0()
+		// If ran on Windows we'd need to allow _test.exe and .test.exe as well.
+		if !hasSuffix(name, "_test") && !hasSuffix(name, ".test") {
+			println("cryptobackend: unexpected code execution in", name)
+			panic("cryptobackend: invalid code execution")
+		}
+	}
+}
+
+func IsRSAKeySupported(primes int) bool {
+	if goexperiment.BoringCrypto {
+		return true
+	}
+	// CNG only supports 2-prime RSA keys.
+	// The built-in OpenSSL 3 providers and OpenSSL 1 do support n-prime RSA keys,
+	// but the SymCrypt provider for OpenSSL only supports 2-prime RSA keys.
+	// Only 2-prime RSA keys are FIPS compliant, other n having compatibility
+	// and security issues. Even crypto/rsa deprecated rsa.GenerateMultiPrimeKey as of Go 1.21.
+	// Given the above reasons, we only support 2-prime RSA keys.
+	return primes == 2
+}
+
+func IsSaltSupported(salt int) bool {
+	return true
+}
diff --git a/src/crypto/internal/backend/fips140/fips140.go b/src/crypto/internal/backend/fips140/fips140.go
new file mode 100644
index 00000000000000..f54d39970319af
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/fips140.go
@@ -0,0 +1,55 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package fips140
+
+import "syscall"
+
+// Enabled reports whether FIPS 140 mode is enabled by using GOFIPS=1, GOLANG_FIPS=1,
+// the 'requirefips' build tag, or any other platform-specific mechanism.
+func Enabled() bool {
+	return enabled
+}
+
+var enabled bool
+
+// Disabled reports whether FIPS 140 mode is disabled by using GOFIPS=0 or GOLANG_FIPS=0.
+func Disabled() bool {
+	return disabled
+}
+
+var disabled bool
+
+// Message is a human-readable message about how [Enabled] was set.
+var Message string
+
+func init() {
+	// TODO: Decide which environment variable to use.
+	// See https://github.com/microsoft/go/issues/397.
+	var value string
+	var ok bool
+	if value, ok = syscall.Getenv("GOFIPS"); ok {
+		Message = "environment variable GOFIPS"
+	} else if value, ok = syscall.Getenv("GOLANG_FIPS"); ok {
+		Message = "environment variable GOLANG_FIPS"
+	} else if systemFIPSMode() {
+		Message = "system FIPS mode"
+		value = "1"
+	}
+	if value == "1" {
+		enabled = true
+	} else if value == "0" {
+		disabled = true
+	}
+	if isRequireFIPS {
+		if disabled {
+			panic("the 'requirefips' build tag is enabled, but it conflicts " +
+				"with the " + Message + "=" + value +
+				" which would disable FIPS mode")
+		}
+		Message = "requirefips tag set"
+		enabled = true
+		return
+	}
+}
\ No newline at end of file
diff --git a/src/crypto/internal/backend/fips140/isrequirefips.go b/src/crypto/internal/backend/fips140/isrequirefips.go
new file mode 100644
index 00000000000000..b33d08c84e2dae
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/isrequirefips.go
@@ -0,0 +1,9 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build requirefips
+
+package fips140
+
+const isRequireFIPS = true
\ No newline at end of file
diff --git a/src/crypto/internal/backend/fips140/norequirefips.go b/src/crypto/internal/backend/fips140/norequirefips.go
new file mode 100644
index 00000000000000..6f01b9a3524dee
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/norequirefips.go
@@ -0,0 +1,9 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !requirefips
+
+package fips140
+
+const isRequireFIPS = false
\ No newline at end of file
diff --git a/src/crypto/internal/backend/fips140/nosystemcrypto.go b/src/crypto/internal/backend/fips140/nosystemcrypto.go
new file mode 100644
index 00000000000000..83691d7dd42d51
--- /dev/null
+++ b/src/crypto/internal/backend/fips140/nosystemcrypto.go
@@ -0,0 +1,11 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package fips140
+
+func systemFIPSMode() bool {
+	return false
+}
diff --git a/src/crypto/internal/backend/nobackend.go b/src/crypto/internal/backend/nobackend.go
new file mode 100644
index 00000000000000..71e0ec9dc25a02
--- /dev/null
+++ b/src/crypto/internal/backend/nobackend.go
@@ -0,0 +1,229 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Do not edit the build constraint by hand. It is generated by "backendgen.go".
+
+//go:build ignore
+
+package backend
+
+import (
+	"crypto"
+	"crypto/cipher"
+	"hash"
+)
+
+const Enabled = false
+
+type BigInt = []uint
+
+type randReader int
+
+func (randReader) Read(b []byte) (int, error) { panic("cryptobackend: not available") }
+
+const RandReader = randReader(0)
+
+func SupportsHash(h crypto.Hash) bool { panic("cryptobackend: not available") }
+
+func NewMD5() hash.Hash    { panic("cryptobackend: not available") }
+func NewSHA1() hash.Hash   { panic("cryptobackend: not available") }
+func NewSHA224() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA256() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA384() hash.Hash { panic("cryptobackend: not available") }
+func NewSHA512() hash.Hash { panic("cryptobackend: not available") }
+
+func MD5(p []byte) (sum [16]byte)    { panic("cryptobackend: not available") }
+func SHA1(p []byte) (sum [20]byte)   { panic("cryptobackend: not available") }
+func SHA224(p []byte) (sum [28]byte) { panic("cryptobackend: not available") }
+func SHA256(p []byte) (sum [32]byte) { panic("cryptobackend: not available") }
+func SHA384(p []byte) (sum [48]byte) { panic("cryptobackend: not available") }
+func SHA512(p []byte) (sum [64]byte) { panic("cryptobackend: not available") }
+
+func NewHMAC(h func() hash.Hash, key []byte) hash.Hash { panic("cryptobackend: not available") }
+
+func NewAESCipher(key []byte) (cipher.Block, error)   { panic("cryptobackend: not available") }
+func NewGCMTLS(c cipher.Block) (cipher.AEAD, error)   { panic("cryptobackend: not available") }
+func NewGCMTLS13(c cipher.Block) (cipher.AEAD, error) { panic("cryptobackend: not available") }
+
+type PublicKeyECDSA struct{ _ int }
+type PrivateKeyECDSA struct{ _ int }
+
+func GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+func NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error) {
+	panic("cryptobackend: not available")
+}
+func SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyRSA struct{ _ int }
+type PrivateKeyRSA struct{ _ int }
+
+func DecryptRSAOAEP(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSAOAEP(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+func NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error) {
+	panic("cryptobackend: not available")
+}
+func SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+func VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error {
+	panic("cryptobackend: not available")
+}
+func VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyECDH struct{}
+type PrivateKeyECDH struct{}
+
+func ECDH(*PrivateKeyECDH, *PublicKeyECDH) ([]byte, error)    { panic("cryptobackend: not available") }
+func GenerateKeyECDH(string) (*PrivateKeyECDH, []byte, error) { panic("cryptobackend: not available") }
+func NewPrivateKeyECDH(string, []byte) (*PrivateKeyECDH, error) {
+	panic("cryptobackend: not available")
+}
+func NewPublicKeyECDH(string, []byte) (*PublicKeyECDH, error) { panic("cryptobackend: not available") }
+func (*PublicKeyECDH) Bytes() []byte                          { panic("cryptobackend: not available") }
+func (*PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error)    { panic("cryptobackend: not available") }
+
+func SupportsHKDF() bool { panic("cryptobackend: not available") }
+
+func ExpandHKDF(h func() hash.Hash, pseudorandomKey, info []byte, keyLength int) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func ExtractHKDF(h func() hash.Hash, secret, salt []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsPBKDF2() bool { panic("cryptobackend: not available") }
+
+func PBKDF2(password, salt []byte, iter, keyLen int, fh func() hash.Hash) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func SupportsTLS1PRF() bool { panic("cryptobackend: not available") }
+
+func TLS1PRF(result, secret, label, seed []byte, h func() hash.Hash) error {
+	panic("cryptobackend: not available")
+}
+
+func SupportsDESCipher() bool { panic("cryptobackend: not available") }
+
+func SupportsTripleDESCipher() bool { panic("cryptobackend: not available") }
+
+func NewDESCipher(key []byte) (cipher.Block, error) { panic("cryptobackend: not available") }
+
+func NewTripleDESCipher(key []byte) (cipher.Block, error) { panic("cryptobackend: not available") }
+
+func SupportsRC4() bool { panic("cryptobackend: not available") }
+
+type RC4Cipher struct{}
+
+func (c *RC4Cipher) Reset()                       { panic("cryptobackend: not available") }
+func (c *RC4Cipher) XORKeyStream(dst, src []byte) { panic("cryptobackend: not available") }
+
+func NewRC4Cipher(key []byte) (*RC4Cipher, error) { panic("cryptobackend: not available") }
+
+func SupportsEd25519() bool { panic("cryptobackend: not available") }
+
+type PublicKeyEd25519 struct{}
+
+func (k *PublicKeyEd25519) Bytes() ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+type PrivateKeyEd25519 struct{}
+
+func (k *PrivateKeyEd25519) Bytes() ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func GenerateKeyEd25519() (*PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyEd25119(priv []byte) (*PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPublicKeyEd25119(pub []byte) (*PublicKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyEd25519FromSeed(seed []byte) (*PrivateKeyEd25519, error) {
+	panic("cryptobackend: not available")
+}
+
+func SignEd25519(priv *PrivateKeyEd25519, message []byte) ([]byte, error) {
+	panic("cryptobackend: not available")
+}
+
+func VerifyEd25519(pub *PublicKeyEd25519, message, sig []byte) error {
+	panic("cryptobackend: not available")
+}
+
+func SupportsDSA(l, n int) bool {
+	panic("cryptobackend: not available")
+}
+
+func GenerateParametersDSA(l, n int) (p, q, g BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+type PublicKeyDSA struct{ _ int }
+type PrivateKeyDSA struct{ _ int }
+
+func GenerateKeyDSA(p, q, g BigInt) (x, y BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPrivateKeyDSA(p, q, g, x, y BigInt) (*PrivateKeyDSA, error) {
+	panic("cryptobackend: not available")
+}
+
+func NewPublicKeyDSA(p, q, g, y BigInt) (*PublicKeyDSA, error) {
+	panic("cryptobackend: not available")
+}
+
+func SignDSA(priv *PrivateKeyDSA, hash []byte, parseSignature func([]byte) (BigInt, BigInt, error)) (r, s BigInt, err error) {
+	panic("cryptobackend: not available")
+}
+
+func VerifyDSA(pub *PublicKeyDSA, hashed []byte, r, s BigInt, encodeSignature func(r, s BigInt) ([]byte, error)) bool {
+	panic("cryptobackend: not available")
+}
diff --git a/src/crypto/internal/backend/stub.s b/src/crypto/internal/backend/stub.s
new file mode 100644
index 00000000000000..5e4b436554d44d
--- /dev/null
+++ b/src/crypto/internal/backend/stub.s
@@ -0,0 +1,10 @@
+// Copyright 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// runtime_arg0 is declared in common.go without a body.
+// It's provided by package runtime,
+// but the go command doesn't know that.
+// Having this assembly file keeps the go command
+// from complaining about the missing body
+// (because the implementation might be here).
diff --git a/src/crypto/internal/cryptotest/allocations.go b/src/crypto/internal/cryptotest/allocations.go
index 70055af70b42ec..3c4b4fbaa98ded 100644
--- a/src/crypto/internal/cryptotest/allocations.go
+++ b/src/crypto/internal/cryptotest/allocations.go
@@ -5,7 +5,7 @@
 package cryptotest
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"internal/asan"
 	"internal/msan"
 	"internal/race"
diff --git a/src/crypto/internal/cryptotest/implementations.go b/src/crypto/internal/cryptotest/implementations.go
index 3fa730459050f6..1f28f12a6e7b4f 100644
--- a/src/crypto/internal/cryptotest/implementations.go
+++ b/src/crypto/internal/cryptotest/implementations.go
@@ -5,7 +5,7 @@
 package cryptotest
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/impl"
 	"internal/goos"
 	"internal/testenv"
diff --git a/src/crypto/md5/md5.go b/src/crypto/md5/md5.go
index 75e1fc7404724a..60428f8e1201de 100644
--- a/src/crypto/md5/md5.go
+++ b/src/crypto/md5/md5.go
@@ -12,6 +12,7 @@ package md5
 
 import (
 	"crypto"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140only"
 	"errors"
 	"hash"
@@ -107,6 +108,9 @@ func New() hash.Hash {
 	if fips140only.Enabled {
 		panic("crypto/md5: use of MD5 is not allowed in FIPS 140-only mode")
 	}
+	if boring.Enabled && boring.SupportsHash(crypto.MD5) {
+		return boring.NewMD5()
+	}
 	d := new(digest)
 	d.Reset()
 	return d
@@ -187,6 +191,9 @@ func Sum(data []byte) [Size]byte {
 	if fips140only.Enabled {
 		panic("crypto/md5: use of MD5 is not allowed in FIPS 140-only mode")
 	}
+	if boring.Enabled && boring.SupportsHash(crypto.MD5) {
+		return boring.MD5(data)
+	}
 	var d digest
 	d.Reset()
 	d.Write(data)
diff --git a/src/crypto/md5/md5_test.go b/src/crypto/md5/md5_test.go
index 437d9b9d4c0e0d..5bc3e7b0f8435f 100644
--- a/src/crypto/md5/md5_test.go
+++ b/src/crypto/md5/md5_test.go
@@ -6,6 +6,7 @@ package md5
 
 import (
 	"bytes"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/rand"
 	"encoding"
@@ -88,6 +89,11 @@ func TestGolden(t *testing.T) {
 }
 
 func TestGoldenMarshal(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryMarshaler); !ok {
+			t.Skip("BinaryMarshaler not implemented")
+		}
+	}
 	for _, g := range golden {
 		h := New()
 		h2 := New()
@@ -157,6 +163,9 @@ func TestLarge(t *testing.T) {
 
 // Tests that blockGeneric (pure Go) and block (in assembly for amd64, 386, arm) match.
 func TestBlockGeneric(t *testing.T) {
+	if boring.Enabled {
+		t.Skip("digest is not used when boring.Enabled is set")
+	}
 	gen, asm := New().(*digest), New().(*digest)
 	buf := make([]byte, BlockSize*20) // arbitrary factor
 	rand.Read(buf)
@@ -204,6 +213,11 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 }
 
 func TestLargeHashes(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryUnmarshaler); !ok {
+			t.Skip("BinaryUnmarshaler not implemented")
+		}
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
diff --git a/src/crypto/pbkdf2/pbkdf2.go b/src/crypto/pbkdf2/pbkdf2.go
index 0fdd9e822d40a5..bc8e560487a6ef 100644
--- a/src/crypto/pbkdf2/pbkdf2.go
+++ b/src/crypto/pbkdf2/pbkdf2.go
@@ -19,6 +19,7 @@ pbkdf2.Key.
 package pbkdf2
 
 import (
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/pbkdf2"
 	"crypto/internal/fips140only"
 	"errors"
@@ -53,5 +54,8 @@ func Key[Hash hash.Hash](h func() Hash, password string, salt []byte, iter, keyL
 			return nil, errors.New("crypto/pbkdf2: use of hash functions other than SHA-2 or SHA-3 is not allowed in FIPS 140-only mode")
 		}
 	}
+	if boring.Enabled && boring.SupportsPBKDF2() {
+		return boring.PBKDF2([]byte(password), salt, iter, keyLength, func() hash.Hash { return h() })
+	}
 	return pbkdf2.Key(h, password, salt, iter, keyLength)
 }
diff --git a/src/crypto/pbkdf2/pbkdf2_test.go b/src/crypto/pbkdf2/pbkdf2_test.go
index 03980c7e54d3be..4968a666fad4e5 100644
--- a/src/crypto/pbkdf2/pbkdf2_test.go
+++ b/src/crypto/pbkdf2/pbkdf2_test.go
@@ -6,7 +6,7 @@ package pbkdf2_test
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	"crypto/pbkdf2"
 	"crypto/sha1"
diff --git a/src/crypto/purego_test.go b/src/crypto/purego_test.go
index 62be347e0c6822..d284b5cf7814a6 100644
--- a/src/crypto/purego_test.go
+++ b/src/crypto/purego_test.go
@@ -41,7 +41,7 @@ func TestPureGoTag(t *testing.T) {
 	}
 
 	for _, pkgName := range pkgs {
-		if strings.Contains(pkgName, "/boring") {
+		if strings.Contains(pkgName, "/boring") || strings.Contains(pkgName, "/internal/backend") || strings.Contains(pkgName, "tls/fipsonly") {
 			continue
 		}
 
diff --git a/src/crypto/rand/rand.go b/src/crypto/rand/rand.go
index 1ca16caa9563e6..3ef22b5ff8222b 100644
--- a/src/crypto/rand/rand.go
+++ b/src/crypto/rand/rand.go
@@ -7,7 +7,7 @@
 package rand
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	"crypto/internal/fips140/drbg"
 	"crypto/internal/sysrand"
diff --git a/src/crypto/rc4/rc4.go b/src/crypto/rc4/rc4.go
index 90943a0935befb..09ebdfd733e5d6 100644
--- a/src/crypto/rc4/rc4.go
+++ b/src/crypto/rc4/rc4.go
@@ -10,6 +10,7 @@
 package rc4
 
 import (
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/alias"
 	"crypto/internal/fips140only"
 	"errors"
@@ -20,6 +21,8 @@ import (
 type Cipher struct {
 	s    [256]uint32
 	i, j uint8
+
+	boring *boring.RC4Cipher
 }
 
 type KeySizeError int
@@ -38,6 +41,13 @@ func NewCipher(key []byte) (*Cipher, error) {
 	if k < 1 || k > 256 {
 		return nil, KeySizeError(k)
 	}
+	if boring.Enabled && boring.SupportsRC4() {
+		c, err := boring.NewRC4Cipher(key)
+		if err != nil {
+			return nil, err
+		}
+		return &Cipher{boring: c}, nil
+	}
 	var c Cipher
 	for i := 0; i < 256; i++ {
 		c.s[i] = uint32(i)
@@ -55,6 +65,10 @@ func NewCipher(key []byte) (*Cipher, error) {
 // Deprecated: Reset can't guarantee that the key will be entirely removed from
 // the process's memory.
 func (c *Cipher) Reset() {
+	if boring.Enabled && boring.SupportsRC4() {
+		c.boring.Reset()
+		return
+	}
 	for i := range c.s {
 		c.s[i] = 0
 	}
@@ -64,6 +78,10 @@ func (c *Cipher) Reset() {
 // XORKeyStream sets dst to the result of XORing src with the key stream.
 // Dst and src must overlap entirely or not at all.
 func (c *Cipher) XORKeyStream(dst, src []byte) {
+	if boring.Enabled && boring.SupportsRC4() {
+		c.boring.XORKeyStream(dst, src)
+		return
+	}
 	if len(src) == 0 {
 		return
 	}
diff --git a/src/crypto/rsa/boring.go b/src/crypto/rsa/boring.go
index b9f9d3154f2589..d52faddef45549 100644
--- a/src/crypto/rsa/boring.go
+++ b/src/crypto/rsa/boring.go
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package rsa
 
 import (
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/boring/bcache"
 	"math/big"
 )
diff --git a/src/crypto/rsa/boring_test.go b/src/crypto/rsa/boring_test.go
index 838fcc1244bdbe..d89f732345e8a3 100644
--- a/src/crypto/rsa/boring_test.go
+++ b/src/crypto/rsa/boring_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 // Note: Can run these tests against the non-BoringCrypto
 // version of the code by using "CGO_ENABLED=0 go test".
diff --git a/src/crypto/rsa/fips.go b/src/crypto/rsa/fips.go
index 24dfb38cf625bd..ccb027810a7e07 100644
--- a/src/crypto/rsa/fips.go
+++ b/src/crypto/rsa/fips.go
@@ -6,7 +6,7 @@ package rsa
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/rsa"
 	"crypto/internal/fips140only"
 	"errors"
@@ -78,7 +78,7 @@ func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte,
 		hash = opts.Hash
 	}
 
-	if boring.Enabled && rand == boring.RandReader {
+	if boring.Enabled && rand == boring.RandReader && boring.IsRSAKeySupported(len(priv.Primes)) && boring.SupportsHash(hash) {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -136,7 +136,7 @@ func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts
 		return errors.New("crypto/rsa: use of hash functions other than SHA-2 or SHA-3 is not allowed in FIPS 140-only mode")
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.IsSaltSupported(opts.saltLength()) && boring.SupportsHash(hash) {
 		bkey, err := boringPublicKey(pub)
 		if err != nil {
 			return err
@@ -249,7 +249,7 @@ func decryptOAEP(hash, mgfHash hash.Hash, priv *PrivateKey, ciphertext []byte, l
 		}
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.IsRSAKeySupported(len(priv.Primes)) {
 		k := priv.Size()
 		if len(ciphertext) > k ||
 			k < hash.Size()*2+2 {
@@ -305,7 +305,7 @@ func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed [
 		return nil, errors.New("crypto/rsa: use of hash functions other than SHA-2 or SHA-3 is not allowed in FIPS 140-only mode")
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.IsRSAKeySupported(len(priv.Primes)) {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
diff --git a/src/crypto/rsa/notboring.go b/src/crypto/rsa/notboring.go
index 2abc0436405f8a..3e4d6f3eef61e6 100644
--- a/src/crypto/rsa/notboring.go
+++ b/src/crypto/rsa/notboring.go
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build !boringcrypto
+//go:build !goexperiment.systemcrypto
 
 package rsa
 
-import "crypto/internal/boring"
+import boring "crypto/internal/backend"
 
 func boringPublicKey(*PublicKey) (*boring.PublicKeyRSA, error) {
 	panic("boringcrypto: not available")
diff --git a/src/crypto/rsa/pkcs1v15.go b/src/crypto/rsa/pkcs1v15.go
index f1e4ef48a4fd1c..cb5aa30920bb7d 100644
--- a/src/crypto/rsa/pkcs1v15.go
+++ b/src/crypto/rsa/pkcs1v15.go
@@ -5,7 +5,7 @@
 package rsa
 
 import (
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/rsa"
 	"crypto/internal/fips140only"
 	"crypto/internal/randutil"
@@ -104,7 +104,7 @@ func DecryptPKCS1v15(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]b
 		return nil, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.IsRSAKeySupported(len(priv.Primes)) {
 		bkey, err := boringPrivateKey(priv)
 		if err != nil {
 			return nil, err
@@ -203,7 +203,7 @@ func decryptPKCS1v15(priv *PrivateKey, ciphertext []byte) (valid int, em []byte,
 		return 0, nil, 0, err
 	}
 
-	if boring.Enabled {
+	if boring.Enabled && boring.IsRSAKeySupported(len(priv.Primes)) {
 		var bkey *boring.PrivateKeyRSA
 		bkey, err = boringPrivateKey(priv)
 		if err != nil {
diff --git a/src/crypto/rsa/pkcs1v15_test.go b/src/crypto/rsa/pkcs1v15_test.go
index c65552cd93526a..910416abe842f5 100644
--- a/src/crypto/rsa/pkcs1v15_test.go
+++ b/src/crypto/rsa/pkcs1v15_test.go
@@ -7,6 +7,7 @@ package rsa_test
 import (
 	"bytes"
 	"crypto"
+	boring "crypto/internal/backend"
 	"crypto/rand"
 	. "crypto/rsa"
 	"crypto/sha1"
@@ -235,6 +236,10 @@ func TestVerifyPKCS1v15(t *testing.T) {
 }
 
 func TestOverlongMessagePKCS1v15(t *testing.T) {
+	if boring.Enabled {
+		// See for example https://github.com/golang-fips/openssl/pull/142.
+		t.Skip("Some backends do not return an error for overlong messages.")
+	}
 	t.Setenv("GODEBUG", "rsa1024min=0")
 	ciphertext := decodeBase64("fjOVdirUzFoLlukv80dBllMLjXythIf22feqPrNo0YoIjzyzyoMFiLjAc/Y4krkeZ11XFThIrEvw\nkRiZcCq5ng==")
 	_, err := DecryptPKCS1v15(nil, test512Key, ciphertext)
diff --git a/src/crypto/rsa/pss_test.go b/src/crypto/rsa/pss_test.go
index e03f4ab06603c6..a4af0a2144870a 100644
--- a/src/crypto/rsa/pss_test.go
+++ b/src/crypto/rsa/pss_test.go
@@ -8,6 +8,7 @@ import (
 	"bufio"
 	"compress/bzip2"
 	"crypto"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140"
 	"crypto/rand"
 	. "crypto/rsa"
@@ -180,6 +181,10 @@ func TestPSSSigning(t *testing.T) {
 			continue
 		}
 
+		if boring.Enabled && test.good != test.fipsGood {
+			t.Skip("skipping test with different results when using different backends")
+		}
+
 		opts.SaltLength = test.verifySaltLength
 		err = VerifyPSS(&rsaPrivateKey.PublicKey, hash, hashed, sig, &opts)
 		good := test.good
diff --git a/src/crypto/rsa/rsa.go b/src/crypto/rsa/rsa.go
index fb23f003a6f217..be374dad6969d5 100644
--- a/src/crypto/rsa/rsa.go
+++ b/src/crypto/rsa/rsa.go
@@ -42,8 +42,8 @@ package rsa
 
 import (
 	"crypto"
-	"crypto/internal/boring"
-	"crypto/internal/boring/bbig"
+	boring "crypto/internal/backend"
+	"crypto/internal/backend/bbig"
 	"crypto/internal/fips140/bigmod"
 	"crypto/internal/fips140/rsa"
 	"crypto/internal/fips140only"
diff --git a/src/crypto/rsa/rsa_test.go b/src/crypto/rsa/rsa_test.go
index 2474ab82dfa207..78e9b47f051484 100644
--- a/src/crypto/rsa/rsa_test.go
+++ b/src/crypto/rsa/rsa_test.go
@@ -8,7 +8,7 @@ import (
 	"bufio"
 	"bytes"
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/rand"
 	. "crypto/rsa"
@@ -129,6 +129,11 @@ func testKeyBasics(t *testing.T, priv *PrivateKey) {
 	if priv.D.Cmp(priv.N) > 0 {
 		t.Errorf("private exponent too large")
 	}
+	if boring.Enabled && priv.N.BitLen() < 512 {
+		// Some crypto backends (e.g. CNG and OpenSSL with SymCrypt) don't support key sizes
+		// lower than 512 and intentionally fail rather than fall back to Go crypto.
+		t.Skip("skipping allocations test with BoringCrypto")
+	}
 
 	msg := []byte("hi!")
 	enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
@@ -209,6 +214,11 @@ func testEverything(t *testing.T, priv *PrivateKey) {
 	if err := priv.Validate(); err != nil {
 		t.Errorf("Validate() failed: %s", err)
 	}
+	if boring.Enabled && priv.N.BitLen() < 512 {
+		// Some crypto backends (e.g. CNG and OpenSSL with SymCrypt) don't support key sizes
+		// lower than 512 and intentionally fail rather than fall back to Go crypto.
+		t.Skip("skipping allocations test with BoringCrypto")
+	}
 
 	msg := []byte("test")
 	enc, err := EncryptPKCS1v15(rand.Reader, &priv.PublicKey, msg)
diff --git a/src/crypto/sha1/sha1.go b/src/crypto/sha1/sha1.go
index b799f0d2fb1548..9aa23e9aa17e89 100644
--- a/src/crypto/sha1/sha1.go
+++ b/src/crypto/sha1/sha1.go
@@ -10,7 +10,7 @@ package sha1
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140only"
 	"errors"
 	"hash"
diff --git a/src/crypto/sha1/sha1_test.go b/src/crypto/sha1/sha1_test.go
index 9d707b7cde5c2d..cb0c343afc46b6 100644
--- a/src/crypto/sha1/sha1_test.go
+++ b/src/crypto/sha1/sha1_test.go
@@ -8,7 +8,7 @@ package sha1
 
 import (
 	"bytes"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"crypto/rand"
 	"encoding"
@@ -97,6 +97,11 @@ func TestGolden(t *testing.T) {
 }
 
 func TestGoldenMarshal(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryMarshaler); !ok {
+			t.Skip("BinaryMarshaler not implemented")
+		}
+	}
 	h := New()
 	h2 := New()
 	for _, g := range golden {
@@ -210,6 +215,11 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 }
 
 func TestLargeHashes(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryMarshaler); !ok {
+			t.Skip("BinaryMarshaler not implemented")
+		}
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
diff --git a/src/crypto/sha256/sha256.go b/src/crypto/sha256/sha256.go
index 069938a22dbc5a..8d0e06b86f4359 100644
--- a/src/crypto/sha256/sha256.go
+++ b/src/crypto/sha256/sha256.go
@@ -8,7 +8,7 @@ package sha256
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/sha256"
 	"hash"
 )
@@ -43,7 +43,7 @@ func New() hash.Hash {
 // [encoding.BinaryUnmarshaler] to marshal and unmarshal the internal
 // state of the hash.
 func New224() hash.Hash {
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsHash(crypto.SHA224) {
 		return boring.NewSHA224()
 	}
 	return sha256.New224()
@@ -63,7 +63,7 @@ func Sum256(data []byte) [Size]byte {
 
 // Sum224 returns the SHA224 checksum of the data.
 func Sum224(data []byte) [Size224]byte {
-	if boring.Enabled {
+	if boring.Enabled && boring.SupportsHash(crypto.SHA224) {
 		return boring.SHA224(data)
 	}
 	h := New224()
diff --git a/src/crypto/sha256/sha256_test.go b/src/crypto/sha256/sha256_test.go
index e1af9640e25547..41df7dbebf7e7a 100644
--- a/src/crypto/sha256/sha256_test.go
+++ b/src/crypto/sha256/sha256_test.go
@@ -8,6 +8,7 @@ package sha256
 
 import (
 	"bytes"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"encoding"
 	"fmt"
@@ -155,6 +156,11 @@ func testGoldenMarshal(t *testing.T) {
 
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
+			if boring.Enabled {
+				if _, ok := tt.newHash().(encoding.BinaryMarshaler); !ok {
+					t.Skip("BinaryMarshaler not implemented")
+				}
+			}
 			for _, g := range tt.gold {
 				h := tt.newHash()
 				h2 := tt.newHash()
@@ -204,6 +210,14 @@ func TestMarshalTypeMismatch(t *testing.T) {
 	h1 := New()
 	h2 := New224()
 
+	if boring.Enabled {
+		_, ok1 := h1.(encoding.BinaryMarshaler)
+		_, ok2 := h2.(encoding.BinaryUnmarshaler)
+		if !ok1 || !ok2 {
+			t.Skip("BinaryMarshaler not implemented")
+		}
+	}
+
 	state1, err := h1.(encoding.BinaryMarshaler).MarshalBinary()
 	if err != nil {
 		t.Errorf("could not marshal: %v", err)
@@ -275,6 +289,11 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 	return h.Sum(nil), nil
 }
 func TestLargeHashes(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryUnmarshaler); !ok {
+			t.Skip("BinaryUnmarshaler not implemented")
+		}
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
diff --git a/src/crypto/sha512/sha512.go b/src/crypto/sha512/sha512.go
index 1435eac1f5b5dc..17e8501154762a 100644
--- a/src/crypto/sha512/sha512.go
+++ b/src/crypto/sha512/sha512.go
@@ -12,7 +12,7 @@ package sha512
 
 import (
 	"crypto"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/sha512"
 	"hash"
 )
diff --git a/src/crypto/sha512/sha512_test.go b/src/crypto/sha512/sha512_test.go
index 1fe9d132bb186d..a2c2926359a192 100644
--- a/src/crypto/sha512/sha512_test.go
+++ b/src/crypto/sha512/sha512_test.go
@@ -8,6 +8,7 @@ package sha512
 
 import (
 	"bytes"
+	boring "crypto/internal/backend"
 	"crypto/internal/cryptotest"
 	"encoding"
 	"encoding/hex"
@@ -744,6 +745,11 @@ func testGoldenMarshal(t *testing.T) {
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
 			for _, test := range tt.golden {
+				if boring.Enabled {
+					if _, ok := tt.newHash().(encoding.BinaryMarshaler); !ok {
+						t.Skip("BinaryMarshaler not implemented")
+					}
+				}
 				h := tt.newHash()
 				h2 := tt.newHash()
 
@@ -805,6 +811,14 @@ func TestMarshalMismatch(t *testing.T) {
 			h1 := fn1()
 			h2 := fn2()
 
+			if boring.Enabled {
+				_, ok1 := h1.(encoding.BinaryMarshaler)
+				_, ok2 := h2.(encoding.BinaryUnmarshaler)
+				if !ok1 || !ok2 {
+					t.Skip("BinaryMarshaler not implemented")
+				}
+			}
+
 			state, err := h1.(encoding.BinaryMarshaler).MarshalBinary()
 			if err != nil {
 				t.Errorf("i=%d: could not marshal: %v", i, err)
@@ -880,6 +894,11 @@ func safeSum(h hash.Hash) (sum []byte, err error) {
 }
 
 func TestLargeHashes(t *testing.T) {
+	if boring.Enabled {
+		if _, ok := New().(encoding.BinaryUnmarshaler); !ok {
+			t.Skip("BinaryUnmarshaler not implemented")
+		}
+	}
 	for i, test := range largeUnmarshalTests {
 
 		h := New()
diff --git a/src/crypto/tls/cipher_suites.go b/src/crypto/tls/cipher_suites.go
index 01d65688284f97..d8a26c24024348 100644
--- a/src/crypto/tls/cipher_suites.go
+++ b/src/crypto/tls/cipher_suites.go
@@ -10,7 +10,7 @@ import (
 	"crypto/cipher"
 	"crypto/des"
 	"crypto/hmac"
-	"crypto/internal/boring"
+	boring "crypto/internal/backend"
 	fipsaes "crypto/internal/fips140/aes"
 	"crypto/internal/fips140/aes/gcm"
 	"crypto/rc4"
diff --git a/src/crypto/tls/fipsonly/fipsonly.go b/src/crypto/tls/fipsonly/fipsonly.go
index e702f44e986746..e506a0d8841237 100644
--- a/src/crypto/tls/fipsonly/fipsonly.go
+++ b/src/crypto/tls/fipsonly/fipsonly.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 // Package fipsonly restricts all TLS configuration to FIPS-approved settings.
 //
diff --git a/src/crypto/tls/fipsonly/fipsonly_test.go b/src/crypto/tls/fipsonly/fipsonly_test.go
index 027bc22c33c921..eba08da985f832 100644
--- a/src/crypto/tls/fipsonly/fipsonly_test.go
+++ b/src/crypto/tls/fipsonly/fipsonly_test.go
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
-//go:build boringcrypto
+//go:build goexperiment.systemcrypto
 
 package fipsonly
 
diff --git a/src/crypto/tls/handshake_client.go b/src/crypto/tls/handshake_client.go
index ecc62ff2edefc0..776fec96f0f349 100644
--- a/src/crypto/tls/handshake_client.go
+++ b/src/crypto/tls/handshake_client.go
@@ -548,7 +548,15 @@ func (c *Conn) pickTLSVersion(serverHello *serverHelloMsg) error {
 
 // Does the handshake, either a full one or resumes old session. Requires hs.c,
 // hs.hello, hs.serverHello, and, optionally, hs.session to be set.
-func (hs *clientHandshakeState) handshake() error {
+func (hs *clientHandshakeState) handshake() (err error) {
+	defer func() {
+		if err == nil {
+			err = recoverFromBoringPRFError()
+			if err != nil {
+				hs.c.sendAlert(alertInternalError)
+			}
+		}
+	}()
 	c := hs.c
 
 	isResume, err := hs.processServerHello()
diff --git a/src/crypto/tls/handshake_server.go b/src/crypto/tls/handshake_server.go
index 7c75977ad3ffb2..b9db95ca7b9d5a 100644
--- a/src/crypto/tls/handshake_server.go
+++ b/src/crypto/tls/handshake_server.go
@@ -64,7 +64,15 @@ func (c *Conn) serverHandshake(ctx context.Context) error {
 	return hs.handshake()
 }
 
-func (hs *serverHandshakeState) handshake() error {
+func (hs *serverHandshakeState) handshake() (err error) {
+	defer func() {
+		if err == nil {
+			err = recoverFromBoringPRFError()
+			if err != nil {
+				hs.c.sendAlert(alertInternalError)
+			}
+		}
+	}()
 	c := hs.c
 
 	if err := hs.processClientHello(); err != nil {
diff --git a/src/crypto/tls/handshake_server_tls13.go b/src/crypto/tls/handshake_server_tls13.go
index 3552d89ba3bc6f..958ec81dc64966 100644
--- a/src/crypto/tls/handshake_server_tls13.go
+++ b/src/crypto/tls/handshake_server_tls13.go
@@ -9,6 +9,7 @@ import (
 	"context"
 	"crypto"
 	"crypto/hmac"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/hkdf"
 	"crypto/internal/fips140/mlkem"
 	"crypto/internal/fips140/tls13"
@@ -477,6 +478,15 @@ func cloneHash(in hash.Hash, h crypto.Hash) hash.Hash {
 	}
 	marshaler, ok := in.(binaryMarshaler)
 	if !ok {
+		if boring.Enabled {
+			// CNG and OpenSSL with SymCrypt hash functions do not implement the
+			// encoding.BinaryMarshaler interface, but they do implement the Clone method.
+			if cloner, ok := in.(interface{ Clone() (hash.Hash, error) }); ok {
+				if out, err := cloner.Clone(); err == nil {
+					return out
+				}
+			}
+		}
 		return nil
 	}
 	state, err := marshaler.MarshalBinary()
diff --git a/src/crypto/tls/internal/fips140tls/fipstls.go b/src/crypto/tls/internal/fips140tls/fipstls.go
index 24d78d60cf5b64..a6bfd3f17c1911 100644
--- a/src/crypto/tls/internal/fips140tls/fipstls.go
+++ b/src/crypto/tls/internal/fips140tls/fipstls.go
@@ -6,6 +6,7 @@
 package fips140tls
 
 import (
+	bfips140 "crypto/internal/backend/fips140"
 	"crypto/internal/fips140"
 	"sync/atomic"
 )
@@ -13,7 +14,7 @@ import (
 var required atomic.Bool
 
 func init() {
-	if fips140.Enabled {
+	if fips140.Enabled || bfips140.Enabled() {
 		Force()
 	}
 }
diff --git a/src/crypto/tls/prf.go b/src/crypto/tls/prf.go
index e7369542a73270..ff52175e4ac636 100644
--- a/src/crypto/tls/prf.go
+++ b/src/crypto/tls/prf.go
@@ -7,6 +7,7 @@ package tls
 import (
 	"crypto"
 	"crypto/hmac"
+	boring "crypto/internal/backend"
 	"crypto/internal/fips140/tls12"
 	"crypto/md5"
 	"crypto/sha1"
@@ -47,9 +48,42 @@ func pHash(result, secret, seed []byte, hash func() hash.Hash) {
 	}
 }
 
+type boringPRFError struct {
+	err error
+}
+
+func (e *boringPRFError) Error() string {
+	return e.err.Error()
+}
+
+// recoverFromBoringPRFError recovers from a panic caused by the boring backend.
+// It returns the error if it was a boringPRFError, or panics if the panic was
+// caused by something else.
+func recoverFromBoringPRFError() error {
+	if p := recover(); p != nil {
+		if err, ok := p.(boringPRFError); ok {
+			// Could happen, for example, if the seed is too large. The Go implementation doesn't limit the seed size,
+			// as RFC 5705 doesn't specify a limit, but stock OpenSSL restrict it to 1024 and CNG to 256.
+			return err.err
+		}
+		panic(p)
+	}
+	return nil
+}
+
+func panicBoringPRFError(err error) {
+	panic(boringPRFError{err})
+}
+
 // prf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, Section 5.
 func prf10(secret []byte, label string, seed []byte, keyLen int) []byte {
 	result := make([]byte, keyLen)
+	if boring.Enabled && boring.SupportsTLS1PRF() {
+		if err := boring.TLS1PRF(result, secret, []byte(label), seed, nil); err != nil {
+			panicBoringPRFError(fmt.Errorf("crypto/tls: prf10: %v", err))
+		}
+		return result
+	}
 	hashSHA1 := sha1.New
 	hashMD5 := md5.New
 
@@ -72,6 +106,13 @@ func prf10(secret []byte, label string, seed []byte, keyLen int) []byte {
 // prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, Section 5.
 func prf12(hashFunc func() hash.Hash) prfFunc {
 	return func(secret []byte, label string, seed []byte, keyLen int) []byte {
+		if boring.Enabled && boring.SupportsTLS1PRF() {
+			result := make([]byte, keyLen)
+			if err := boring.TLS1PRF(result, secret, []byte(label), seed, hashFunc); err != nil {
+				panicBoringPRFError(fmt.Errorf("crypto/tls: prf12: %v", err))
+			}
+			return result
+		}
 		return tls12.PRF(hashFunc, secret, label, seed, keyLen)
 	}
 }
diff --git a/src/go/build/deps_test.go b/src/go/build/deps_test.go
index cc7f4df7f388ea..58082b3636f209 100644
--- a/src/go/build/deps_test.go
+++ b/src/go/build/deps_test.go
@@ -491,9 +491,11 @@ var depsRules = `
 	< crypto/internal/fips140/rsa
 	< FIPS;
 
+	syscall < crypto/internal/backend/fips140;
+
 	FIPS < crypto/internal/fips140/check/checktest;
 
-	FIPS, sync/atomic < crypto/tls/internal/fips140tls;
+	FIPS, sync/atomic, crypto/internal/backend/fips140 < crypto/tls/internal/fips140tls;
 
 	FIPS, internal/godebug, hash < crypto/fips140, crypto/internal/fips140only;
 
@@ -505,6 +507,7 @@ var depsRules = `
 	FIPS, crypto/internal/fips140only,
 	crypto/internal/boring/sig,
 	crypto/internal/boring/syso,
+	encoding/binary,
 	golang.org/x/sys/cpu,
 	hash, embed
 	< crypto
@@ -514,7 +517,9 @@ var depsRules = `
 
 	crypto/cipher,
 	crypto/internal/boring/bcache
+	crypto/internal/backend/fips140
 	< crypto/internal/boring
+	< crypto/internal/backend
 	< crypto/boring;
 
 	crypto/boring
@@ -546,6 +551,7 @@ var depsRules = `
 	# CRYPTO-MATH is core bignum-based crypto - no cgo, net; fmt now ok.
 	CRYPTO, FMT, math/big
 	< crypto/internal/boring/bbig
+	< crypto/internal/backend/bbig
 	< crypto/rand
 	< crypto/ed25519
 	< encoding/asn1
diff --git a/src/hash/boring_test.go b/src/hash/boring_test.go
new file mode 100644
index 00000000000000..52748c44698076
--- /dev/null
+++ b/src/hash/boring_test.go
@@ -0,0 +1,9 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build goexperiment.systemcrypto
+
+package hash_test
+
+const boringEnabled = true
diff --git a/src/hash/example_test.go b/src/hash/example_test.go
index f07b9aaa2c4898..b380537215634d 100644
--- a/src/hash/example_test.go
+++ b/src/hash/example_test.go
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style
 // license that can be found in the LICENSE file.
 
+//go:build !goexperiment.systemcrypto
+
 package hash_test
 
 import (
diff --git a/src/hash/marshal_test.go b/src/hash/marshal_test.go
index 3091f7a67acede..fead8cc4bec73a 100644
--- a/src/hash/marshal_test.go
+++ b/src/hash/marshal_test.go
@@ -65,6 +65,11 @@ func TestMarshalHash(t *testing.T) {
 			}
 
 			h := tt.new()
+			if boringEnabled {
+				if _, ok := h.(encoding.BinaryMarshaler); !ok {
+					t.Skip("BinaryMarshaler not implemented")
+				}
+			}
 			h.Write(buf[:256])
 			sum := h.Sum(nil)
 
diff --git a/src/hash/notboring_test.go b/src/hash/notboring_test.go
new file mode 100644
index 00000000000000..11dc691600b110
--- /dev/null
+++ b/src/hash/notboring_test.go
@@ -0,0 +1,9 @@
+// Copyright 2024 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !goexperiment.systemcrypto
+
+package hash_test
+
+const boringEnabled = false
diff --git a/src/net/smtp/smtp_test.go b/src/net/smtp/smtp_test.go
index 389eda9ad54b99..110d60beb0e70c 100644
--- a/src/net/smtp/smtp_test.go
+++ b/src/net/smtp/smtp_test.go
@@ -1136,40 +1136,60 @@ func sendMail(hostPort string) error {
 
 // localhostCert is a PEM-encoded TLS cert generated from src/crypto/tls:
 //
-//	go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com \
+//	Use a 2048-bits RSA key to make it FIPS-compliant.
+//	go run generate_cert.go --rsa-bits 2048 --host 127.0.0.1,::1,example.com \
 //		--ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h
 var localhostCert = []byte(`
 -----BEGIN CERTIFICATE-----
-MIICFDCCAX2gAwIBAgIRAK0xjnaPuNDSreeXb+z+0u4wDQYJKoZIhvcNAQELBQAw
-EjEQMA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2
-MDAwMFowEjEQMA4GA1UEChMHQWNtZSBDbzCBnzANBgkqhkiG9w0BAQEFAAOBjQAw
-gYkCgYEA0nFbQQuOWsjbGtejcpWz153OlziZM4bVjJ9jYruNw5n2Ry6uYQAffhqa
-JOInCmmcVe2siJglsyH9aRh6vKiobBbIUXXUU1ABd56ebAzlt0LobLlx7pZEMy30
-LqIi9E6zmL3YvdGzpYlkFRnRrqwEtWYbGBf3znO250S56CCWH2UCAwEAAaNoMGYw
-DgYDVR0PAQH/BAQDAgKkMBMGA1UdJQQMMAoGCCsGAQUFBwMBMA8GA1UdEwEB/wQF
-MAMBAf8wLgYDVR0RBCcwJYILZXhhbXBsZS5jb22HBH8AAAGHEAAAAAAAAAAAAAAA
-AAAAAAEwDQYJKoZIhvcNAQELBQADgYEAbZtDS2dVuBYvb+MnolWnCNqvw1w5Gtgi
-NmvQQPOMgM3m+oQSCPRTNGSg25e1Qbo7bgQDv8ZTnq8FgOJ/rbkyERw2JckkHpD4
-n4qcK27WkEDBtQFlPihIM8hLIuzWoi/9wygiElTy/tVL3y7fGCvY2/k1KBthtZGF
-tN8URjVmyEo=
+MIIDOTCCAiGgAwIBAgIQKhWw7zkzXjX78HaPlVbNrjANBgkqhkiG9w0BAQsFADAS
+MRAwDgYDVQQKEwdBY21lIENvMCAXDTcwMDEwMTAwMDAwMFoYDzIwODQwMTI5MTYw
+MDAwWjASMRAwDgYDVQQKEwdBY21lIENvMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
+MIIBCgKCAQEAy1EYLA8IFvZyUPY+uI7KToneaQPvIzQiOeWlDnFnoanw6h3KpoVc
++yNbinK41WfXoSN/1kJ9gmGiFhJTPZ4rQ7DJsD7ethcpuz4uIimdWPohcBzwgbx4
+wjhUgfUsCO6m76fFqrhbkHMDiS2iUjg2gyMVQCrqi8EuBW16yFQdJqPU04p+2rYw
+eJ9lzdeSLR4yvx7p1JS8sS4DbSyrAUaJ9J1sH/gu0nSHNMo7WtIu9K8JmPeYR4X5
+5KLURBU9PmvoGW+5ss/xS6SnacHAD9FebNPQqGB/soBA9gdJIN+5KW0xcE38Zz5Q
+wAAUiU+VlWuZmge0sI8Ix8uIPIvGQSKN0wIDAQABo4GIMIGFMA4GA1UdDwEB/wQE
+AwICpDATBgNVHSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
+DgQWBBRNMP9Cr0yrXpMpsgEtDr8FPmUEazAuBgNVHREEJzAlggtleGFtcGxlLmNv
+bYcEfwAAAYcQAAAAAAAAAAAAAAAAAAAAATANBgkqhkiG9w0BAQsFAAOCAQEAF0/z
+KEnZrAsz4ov4fEvKY42EbKPm8s0pklPLmKVIh/iS7jTxxxvgDtOToiJ6IXY8Cfb3
+nG1i78YakoVPUL5Cfh5LKDefMoefk6575ur2+gSdzgNmKUnlVfOMfpflia/ugATZ
+5ORhpmKRKWzwXQ67S5XeVlZAehTsywQstsDu8WEVoSUnRSk1jZsCThOQfdlpox+K
+71rGPSTxB9yCHMzZsk4xyZlGLaC0vDSJ+Zb5gWvAcvkSnpREvmc3/9TaW/lbUed6
+uhO17lARcUhPCzkR5wAZCo/PihHMSXL8cqT4QdIux75OBxB/3EgLHL7KQw28A50g
+DogldK8zx1ZADmupUA==
 -----END CERTIFICATE-----`)
 
 // localhostKey is the private key for localhostCert.
 var localhostKey = []byte(testingKey(`
 -----BEGIN RSA TESTING KEY-----
-MIICXgIBAAKBgQDScVtBC45ayNsa16NylbPXnc6XOJkzhtWMn2Niu43DmfZHLq5h
-AB9+Gpok4icKaZxV7ayImCWzIf1pGHq8qKhsFshRddRTUAF3np5sDOW3QuhsuXHu
-lkQzLfQuoiL0TrOYvdi90bOliWQVGdGurAS1ZhsYF/fOc7bnRLnoIJYfZQIDAQAB
-AoGBAMst7OgpKyFV6c3JwyI/jWqxDySL3caU+RuTTBaodKAUx2ZEmNJIlx9eudLA
-kucHvoxsM/eRxlxkhdFxdBcwU6J+zqooTnhu/FE3jhrT1lPrbhfGhyKnUrB0KKMM
-VY3IQZyiehpxaeXAwoAou6TbWoTpl9t8ImAqAMY8hlULCUqlAkEA+9+Ry5FSYK/m
-542LujIcCaIGoG1/Te6Sxr3hsPagKC2rH20rDLqXwEedSFOpSS0vpzlPAzy/6Rbb
-PHTJUhNdwwJBANXkA+TkMdbJI5do9/mn//U0LfrCR9NkcoYohxfKz8JuhgRQxzF2
-6jpo3q7CdTuuRixLWVfeJzcrAyNrVcBq87cCQFkTCtOMNC7fZnCTPUv+9q1tcJyB
-vNjJu3yvoEZeIeuzouX9TJE21/33FaeDdsXbRhQEj23cqR38qFHsF1qAYNMCQQDP
-QXLEiJoClkR2orAmqjPLVhR3t2oB3INcnEjLNSq8LHyQEfXyaFfu4U9l5+fRPL2i
-jiC0k/9L5dHUsF0XZothAkEA23ddgRs+Id/HxtojqqUT27B8MT/IGNrYsp4DvS/c
-qgkeluku4GjxRlDMBuXk94xOBEinUs+p/hwP1Alll80Tpg==
+MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDLURgsDwgW9nJQ
+9j64jspOid5pA+8jNCI55aUOcWehqfDqHcqmhVz7I1uKcrjVZ9ehI3/WQn2CYaIW
+ElM9nitDsMmwPt62Fym7Pi4iKZ1Y+iFwHPCBvHjCOFSB9SwI7qbvp8WquFuQcwOJ
+LaJSODaDIxVAKuqLwS4FbXrIVB0mo9TTin7atjB4n2XN15ItHjK/HunUlLyxLgNt
+LKsBRon0nWwf+C7SdIc0yjta0i70rwmY95hHhfnkotREFT0+a+gZb7myz/FLpKdp
+wcAP0V5s09CoYH+ygED2B0kg37kpbTFwTfxnPlDAABSJT5WVa5maB7SwjwjHy4g8
+i8ZBIo3TAgMBAAECggEAc7dv/oN/ozIY1iOQhxId6p1lTHfEv1CIulMNoi7BQK2s
+RFM4Z5Y32WfCTgYFVNCJVVkTBStKq85Npio/3i4Libcw03K05wY/5iX5s8/jkiSq
+q1iNOgm+4SuWTXDw4xSRRo1CX2wWERykwoqKfCkqPXDWQ3Mpkukb/FLXMvVMshRA
+9v9L6MyrCnsFHl8q2J6hcC+RQJ0pb5I4NF6KhMxABWxxxlDO0zYLA0wfhEn8nj/l
+J37QLHmsA7pzxo+NqDTPgpfBuuTbRVGMkC+fPCXYinbubBeURFO2j2yBlseK+Vbd
+sEffiAnPr4ocCz0k0tHAMMY7hKHup2HWuJGFu0IhAQKBgQDkKFEEcYWNx5Ybl1LV
+qr2qIYofpFL+Gu5MWSZxzZbE8u9v0tTsp8SRhXkgjeHY6qjBUBnLgklOKwSigQAm
+j9de44cXjnUIArzeAHsH3fzpYrLfsvBla6wQyr34D0chVCZ0cX/s/zXkSN4PcEkA
+GGfKAENrGskDyc4uq1sIactu8wKBgQDkIL/XT7ysvsaxA+SfIs2CHgb8GNKgtoI1
+QyR0+MfeJGCLwI9qcLbVzXda34qrzQw3YLIm2VHqhzJ4zb0gnyJ4adPZYwpLTgiU
+jVksBVIwBTfbxYvF2+07poCSobCFKLGQnAujhDDIGDAUKQXQmFcqUNWw0QHfQzkS
+xs36H27doQKBgQCjM8+YLRgKbc0LGXhwTHz1GJ6zuZiAGYWB6XddimEhqmDpjVcv
+nWY3bdFSHwuBXYGvHfwFncGP/6eGEl6oNtYpEvoMOKOwQj0VVCStYPZLf4VSDK52
+7ckcDdpLeao4xffn7VRDk97Z1+G4C2q8fbioPv36vCMz6YPp0DsCzqJtTwKBgCUN
+4LtDW10fu7xC6p6ik4jgAbhu+79ZBbtLBZ/uTOCbPgdVJrZeSoRd1FYxWx/etW5F
+SYqf3/tdLGiM2nxy/LFcVynHOYPTz/b5IpPQ5XGhV1peMv7XYyg+OkIW+0oVuwnH
+HujXbukBbMXJiAVCyV25NYx71ncCP0H6grhu5J4hAoGAUaketZWHD/ks9JCoPtfy
+pNnXqrIvTp1cSGJpVUQT/DUqAjevyZ5Q8PFPf09BZ6uYlXtCqsp7pA/fqNdlJRPR
+tHRjpZ5XauBiFdpRNH4tJBTiWWhyuWhkWn369Az7HP3CIlJLeq2FlKCvMClcO4op
+Qc9LHT7jqtcy+LqAVBpsJ/o=
 -----END RSA TESTING KEY-----`))
 
 func testingKey(s string) string { return strings.ReplaceAll(s, "TESTING KEY", "PRIVATE KEY") }
diff --git a/src/runtime/runtime_boring.go b/src/runtime/runtime_boring.go
index 5a98b20253181c..9042f2c2795e19 100644
--- a/src/runtime/runtime_boring.go
+++ b/src/runtime/runtime_boring.go
@@ -17,3 +17,8 @@ func boring_runtime_arg0() string {
 
 //go:linkname fipstls_runtime_arg0 crypto/internal/boring/fipstls.runtime_arg0
 func fipstls_runtime_arg0() string { return boring_runtime_arg0() }
+
+//go:linkname crypto_backend_runtime_arg0 crypto/internal/backend.runtime_arg0
+func crypto_backend_runtime_arg0() string {
+	return boring_runtime_arg0()
+}
